var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Solvers","page":"API Reference","title":"Solvers","text":"","category":"section"},{"location":"api/#Geometry-and-Mesh","page":"API Reference","title":"Geometry and Mesh","text":"","category":"section"},{"location":"api/#Plotting","page":"API Reference","title":"Plotting","text":"","category":"section"},{"location":"api/#MultiGridBarrier3d.fem3d_solve","page":"API Reference","title":"MultiGridBarrier3d.fem3d_solve","text":"fem3d_solve(::Type{T}=Float64; \n            D = [:u :id; :u :dx; :u :dy; :u :dz; :s :id],\n            f = (x) -> T[0.5, 0.0, 0.0, 0.0, 1.0],\n            g = (x) -> T[x[1]^2 + x[2]^2 + x[3]^2, 100.0],\n            rest...) where {T}\n\nSolve a 3D PDE using the Spectral Barrier Method.\n\nArguments\n\nT: Numeric type (default Float64).\nD: Operator structure definition.\nf: Source term function. Must return a Vector of length matching D (default 5).\ng: Boundary condition function.\nrest...: Additional arguments passed to fem3d and amgb (e.g., L, k, maxiter).\n\nReturns\n\nAMGBSOL: Solution object containing the result z and convergence history.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiGridBarrier3d.fem3d","page":"API Reference","title":"MultiGridBarrier3d.fem3d","text":"fem3d(::Type{T}=Float64; L::Int=2, K=nothing, k::Int=3, rest...)\n\nCreate a Geometry object for Q_k elements with L multigrid levels. K is the coarse Q1 mesh (N x 3 matrix). If nothing, defaults to a single cube [-1,1]^3.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiGridBarrier3d.FEM3D","page":"API Reference","title":"MultiGridBarrier3d.FEM3D","text":"FEM3D{k, T}\n\nDiscretization type for 3D hexahedral finite elements of order k.\n\nFields\n\nK::Matrix{T}: Coarse mesh vertices (N x 3).\nL::Int: Number of multigrid levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#PyPlot.plot","page":"API Reference","title":"PyPlot.plot","text":"plot(geo::Geometry, u::Vector; \n     volume=(;), \n     isosurfaces=T[], \n     contour_mesh=(opacity=0.5;),\n     slice_orthogonal=nothing, \n     slice_orthogonal_mesh=(;),\n     slice=nothing, \n     slice_mesh=(;),\n     slice_along_axis=nothing, \n     slice_along_axis_mesh=(;),\n     resolution=(800, 600),\n     show_grid=false,\n     camera_position=nothing,\n     u_name=\"u\")\n\nPlot the solution u on the geometry geo using PyVista. Extends PyPlot.plot.\n\nArguments\n\ngeo: Geometry object.\nu: Solution vector.\nvolume: NamedTuple of options for add_volume (e.g. (cmap=\"viridis\", opacity=\"sigmoid\")). Pass nothing to disable volume rendering.\nisosurfaces: Vector of isosurface values.\ncontour_mesh: NamedTuple of options for add_mesh for the isosurfaces.\nslice_orthogonal: Dictionary or NamedTuple of options for slice_orthogonal filter (e.g., Dict(:x=>0.5) or (x=0.5, y=0.5)).\nslice_orthogonal_mesh: NamedTuple of options for add_mesh for the orthogonal slices.\nslice: Dictionary or NamedTuple of options for slice filter (e.g., Dict(:normal=>\"z\") or (normal=\"z\",)).\nslice_mesh: NamedTuple of options for add_mesh for the slices.\nslice_along_axis: Dictionary or NamedTuple of options for slice_along_axis filter.\nslice_along_axis_mesh: NamedTuple of options for add_mesh for the slices along axis.\nresolution: Image resolution (width, height).\nshow_grid: Show the wireframe grid.\ncamera_position: Optional camera position.\nu_name: Name of the scalar field (default \"u\").\n\nReturns\n\nMGB3DFigure: Object that displays as a PNG in Jupyter.\n\nExamples\n\n# Default volume rendering\nplot(geo, u; volume=(;))\n\n# Volume rendering with specific colormap and opacity\nplot(geo, u; volume=(cmap=\"magma\", opacity=\"linear\"))\n\n# Isosurfaces with custom mesh style\nplot(geo, u; isosurfaces=[0.1, 0.5], contour_mesh=(color=\"black\", opacity=0.5))\n\n# Orthogonal slices\nplot(geo, u; slice_orthogonal=(x=0.0, y=0.0, z=0.0))\n\n# Slices along a normal vector\nplot(geo, u; slice=(normal=[1,1,1], origin=[0,0,0]))\n\n\n\n\n\n","category":"function"},{"location":"api/#PyPlot.savefig","page":"API Reference","title":"PyPlot.savefig","text":"savefig(fig::MGB3DFigure, filename::String)\n\nSave the figure to a file (e.g., \"plot.png\"). Extends PyPlot.savefig.\n\n\n\n\n\n","category":"function"},{"location":"#MultiGridBarrier3d.jl","page":"Home","title":"MultiGridBarrier3d.jl","text":"A Julia package for solving 3D PDEs using the Spectral Barrier Method with hexahedral finite elements.","category":"section"},{"location":"#Demo","page":"Home","title":"Demo","text":"Here is a simple example of solving a 3D problem and plotting the result.\n\nusing MultiGridBarrier3d\n\n# Solve a simple problem on [-1,1]^3\n# -Delta u = f, u = 0 on boundary\n# Default f and g are used.\nsol = fem3d_solve(L=2, k=1, verbose=false)\n\n# Plot the solution\n# This uses PyVista backend but extends PyPlot API\nfig = plot(sol, volume=(;), show_grid=true)\nsavefig(fig, \"fem3d_demo.png\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/sloisel/MultiGridBarrier3d.jl\")","category":"section"}]
}
